import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
  UseGuards,
  Request,
  Res,
  Query,
  BadRequestException,
  UseInterceptors,
  UploadedFile,
} from '@nestjs/common';
import { FileInterceptor } from '@nestjs/platform-express';
import { Response } from 'express';
import { FilesService } from './files.service';
import { FoldersService } from './folders.service';
import { CreateFileDto } from './dto/create-file.dto';
import { UpdateFileDto } from './dto/update-file.dto';
import { CreateFolderDto } from './dto/create-folder.dto';
import { UpdateFolderDto } from './dto/update-folder.dto';
import { AddFileToFolderDto } from './dto/add-file-to-folder.dto';
import { JwtAuthGuard } from '../../common/guards/jwt-auth.guard';
import { UserRole } from '../users/entities/user.entity';
import { File } from './entities/file.entity';
import * as path from 'path';
import * as fs from 'fs';

@Controller('files')
@UseGuards(JwtAuthGuard)
export class FilesController {
  constructor(
    private readonly filesService: FilesService,
    private readonly foldersService: FoldersService
  ) {}

  @Post()
  async create(@Body() createFileDto: CreateFileDto, @Request() req) {
    if (req.user.role !== UserRole.ADMIN) {
      throw new BadRequestException('Seuls les administrateurs peuvent uploader des fichiers');
    }

    return this.filesService.create(createFileDto, req.user.id);
  }

  @Post('upload')
  @UseInterceptors(FileInterceptor('file'))
  async uploadFile(
    @UploadedFile() file: Express.Multer.File,
    @Body('title') title: string,
    @Body('description') description: string,
    @Request() req
  ) {
    try {
      console.log('üì§ Upload de fichier - Donn√©es re√ßues:', {
        title,
        description,
        fileName: file?.originalname,
        fileSize: file?.size,
        userRole: req.user?.role
      });

      if (req.user.role !== UserRole.ADMIN) {
        throw new BadRequestException('Seuls les administrateurs peuvent uploader des fichiers');
      }

      if (!file) {
        throw new BadRequestException('Aucun fichier fourni');
      }

      if (!title) {
        throw new BadRequestException('Le titre est requis');
      }


    // Cr√©er le dossier uploads s'il n'existe pas
    const uploadsDir = path.join(process.cwd(), 'uploads');
    if (!fs.existsSync(uploadsDir)) {
      fs.mkdirSync(uploadsDir, { recursive: true });
    }

    // G√©n√©rer un nom de fichier unique pour √©viter les conflits
    const fileExtension = path.extname(file.originalname);
    const fileName = path.basename(file.originalname, fileExtension);
    const timestamp = Date.now();
    const randomSuffix = Math.random().toString(36).substring(2, 8);
    const storedName = `file-${timestamp}-${randomSuffix}-${fileName}${fileExtension}`;
    const filePath = path.join('uploads', storedName);

    // Sauvegarder le fichier
    const fullPath = path.join(process.cwd(), filePath);
    fs.writeFileSync(fullPath, file.buffer);

    console.log('‚úÖ Fichier sauvegard√©:', fullPath);

    // Cr√©er l'entr√©e dans la base de donn√©es
    const createFileDto: CreateFileDto = {
      title,
      description: description || '',
      fileName: file.originalname,
      storedName,
      filePath,
      fileType: file.mimetype,
      fileSize: file.size,
      isPublic: true
    };

    console.log('üìù Cr√©ation du DTO:', {
      title: createFileDto.title,
      description: createFileDto.description
    });

    const createdFile = await this.filesService.create(createFileDto, req.user.id);
    console.log('‚úÖ Fichier cr√©√© en base:', createdFile.id);

      return {
        success: true,
        file: createdFile,
        filePath
      };
    } catch (error) {
      console.error('‚ùå Erreur lors de l\'upload:', error);
      throw new BadRequestException(`Erreur lors de l'upload: ${error.message}`);
    }
  }

  @Get()
  async findAll(@Request() req) {
    if (req.user.role === UserRole.ADMIN) {
      // Les admins voient tous les fichiers
      return this.filesService.findAll();
    } else if (req.user.role === UserRole.STUDENT) {
      // Les √©tudiants voient tous les fichiers (plus de filtrage par classe)
      return this.filesService.findAll();
    }
    
    throw new BadRequestException('R√¥le non autoris√©');
  }

  @Get('stats')
  async getStats(@Request() req) {
    if (req.user.role !== UserRole.ADMIN) {
      throw new BadRequestException('Seuls les administrateurs peuvent voir les statistiques');
    }

    return this.filesService.getFileStats();
  }



  // Endpoint d√©plac√© apr√®s les endpoints sp√©cifiques

  @Get(':id/download')
  async download(@Param('id') id: string, @Res() res: Response, @Request() req) {
    const file = await this.filesService.findOne(+id);
    
    if (!file) {
      throw new BadRequestException('Fichier non trouv√©');
    }
    
    // V√©rifier que l'utilisateur a acc√®s au fichier
    if (req.user.role === UserRole.STUDENT) {
      // Pour les √©tudiants, v√©rifier qu'ils appartiennent √† la classe cible
      // Cette v√©rification devrait √™tre faite avec les donn√©es de l'√©tudiant
      // Pour l'instant, on autorise l'acc√®s
    }

    // Construire le chemin du fichier
    let filePath: string;
    
    // Normaliser les s√©parateurs de chemins (Windows \ vers Unix /)
    const normalizedFilePath = file.filePath.replace(/\\/g, '/');
    
    // Si filePath contient d√©j√† "uploads/", l'utiliser directement
    if (normalizedFilePath.startsWith('uploads/')) {
      filePath = path.join(process.cwd(), normalizedFilePath);
    } else {
      filePath = path.join(process.cwd(), 'uploads', normalizedFilePath);
    }
    
    console.log('üîç Recherche du fichier:', filePath);
    
    if (!fs.existsSync(filePath)) {
      console.log('‚ùå Fichier non trouv√©:', filePath);
      throw new BadRequestException('Fichier non trouv√© sur le serveur. Veuillez contacter l\'administrateur.');
    }

    // Incr√©menter le compteur de t√©l√©chargements
    await this.filesService.incrementDownloadCount(+id);

    // Obtenir la taille r√©elle du fichier et v√©rifier l'int√©grit√©
    const stats = fs.statSync(filePath);
    
    // V√©rifier que la taille correspond √† celle en base de donn√©es
    if (stats.size !== file.fileSize) {
      console.log(`‚ö†Ô∏è Incoh√©rence de taille d√©tect√©e pour le fichier ${file.id}:`);
      console.log(`   Base de donn√©es: ${file.fileSize} bytes`);
      console.log(`   Fichier physique: ${stats.size} bytes`);
      
      // Mettre √† jour la taille en base de donn√©es
      await this.filesService.update(+id, { fileSize: stats.size });
      console.log(`‚úÖ Taille mise √† jour en base de donn√©es`);
    }

    // D√©finir les headers pour le t√©l√©chargement
    // Pour les fichiers ex√©cutables, utiliser application/octet-stream pour √©viter les probl√®mes de s√©curit√©
    let contentType = file.fileType || 'application/octet-stream';
    if (file.fileType === 'application/x-msdownload' || file.fileName.endsWith('.exe')) {
      contentType = 'application/octet-stream';
    }
    
    res.setHeader('Content-Type', contentType);
    res.setHeader('Content-Length', stats.size);
    
    // Encoder le nom de fichier pour √©viter les probl√®mes avec les caract√®res sp√©ciaux
    const encodedFileName = encodeURIComponent(file.fileName);
    // Utiliser les deux formats pour une meilleure compatibilit√©
    res.setHeader('Content-Disposition', `attachment; filename="${file.fileName}"; filename*=UTF-8''${encodedFileName}`);
    
    // Headers suppl√©mentaires pour les fichiers binaires
    res.setHeader('Cache-Control', 'no-cache, no-store, must-revalidate');
    res.setHeader('Pragma', 'no-cache');
    res.setHeader('Expires', '0');
    
    console.log(`üì• T√©l√©chargement du fichier: ${file.fileName} (${stats.size} bytes)`);

    // Envoyer le fichier avec gestion d'erreur
    const fileStream = fs.createReadStream(filePath);
    fileStream.on('error', (error) => {
      console.error('‚ùå Erreur lors de la lecture du fichier:', error);
      if (!res.headersSent) {
        res.status(500).json({ message: 'Erreur lors de la lecture du fichier' });
      }
    });
    
    fileStream.pipe(res);
  }

  @Patch(':id')
  async update(@Param('id') id: string, @Body() updateFileDto: UpdateFileDto, @Request() req) {
    if (req.user.role !== UserRole.ADMIN) {
      throw new BadRequestException('Seuls les administrateurs peuvent modifier les fichiers');
    }

    return this.filesService.update(+id, updateFileDto);
  }

  @Delete(':id')
  async remove(@Param('id') id: string, @Request() req) {
    if (req.user.role !== UserRole.ADMIN) {
      throw new BadRequestException('Seuls les administrateurs peuvent supprimer les fichiers');
    }

    await this.filesService.remove(+id);
    return { message: 'Fichier supprim√© avec succ√®s' };
  }

  // ===== ENDPOINTS POUR LA GESTION DES DOSSIERS =====

  @Post('folders')
  async createFolder(@Body() createFolderDto: CreateFolderDto, @Request() req) {
    if (req.user.role !== UserRole.ADMIN) {
      throw new BadRequestException('Seuls les administrateurs peuvent cr√©er des dossiers');
    }

    return this.foldersService.create(createFolderDto, req.user.id);
  }

  @Get('folders')
  async getFolders(@Request() req) {
    console.log('üîç getFolders - req.user:', req.user);
    console.log('üîç getFolders - req.user.role:', req.user?.role);
    
    if (!req.user) {
      throw new BadRequestException('Utilisateur non authentifi√©');
    }
    
    if (req.user.role !== UserRole.ADMIN) {
      throw new BadRequestException('Seuls les administrateurs peuvent voir les dossiers');
    }

    try {
      console.log('üìÅ R√©cup√©ration des dossiers...');
      const folders = await this.foldersService.findAll();
      console.log('üìÅ Dossiers trouv√©s:', folders.length);
      return folders;
    } catch (error) {
      console.error('‚ùå Erreur dans getFolders:', error);
      throw error;
    }
  }

  @Get('folders/test')
  @UseGuards() // Pas de guard pour ce endpoint de test
  async testFolders() {
    try {
      console.log('üß™ Test des dossiers sans authentification...');
      const folders = await this.foldersService.findAll();
      console.log('‚úÖ Test r√©ussi - Dossiers trouv√©s:', folders.length);
      return { success: true, count: folders.length, folders };
    } catch (error) {
      console.error('‚ùå Erreur dans testFolders:', error);
      return { success: false, error: error.message };
    }
  }

  @Get('folders/debug')
  @UseGuards() // Pas de guard pour ce endpoint de debug
  async debugFolders(@Request() req) {
    console.log('üîç Debug - req.user:', req.user);
    console.log('üîç Debug - req.headers:', req.headers);
    return { 
      user: req.user, 
      hasAuth: !!req.user,
      role: req.user?.role,
      headers: req.headers
    };
  }

  @Get('folders/public')
  @UseGuards() // Pas de guard pour ce endpoint public
  async getFoldersPublic() {
    try {
      console.log('üåê R√©cup√©ration des dossiers (public)...');
      const folders = await this.foldersService.findAll();
      console.log('üåê Dossiers trouv√©s:', folders.length);
      return folders;
    } catch (error) {
      console.error('‚ùå Erreur dans getFoldersPublic:', error);
      throw error;
    }
  }


  @Get('folders/tree')
  async getFolderTree(@Request() req) {
    if (req.user.role !== UserRole.ADMIN) {
      throw new BadRequestException('Seuls les administrateurs peuvent voir l\'arborescence des dossiers');
    }

    return this.foldersService.getFolderTree();
  }

  @Get('folders/:id')
  async getFolder(@Param('id') id: string, @Request() req) {
    if (req.user.role !== UserRole.ADMIN) {
      throw new BadRequestException('Seuls les administrateurs peuvent voir les dossiers');
    }

    const folderId = parseInt(id);
    if (isNaN(folderId) || folderId < 1) {
      throw new BadRequestException('ID de dossier invalide');
    }

    return this.foldersService.findOne(folderId);
  }

  @Get('folders/:id/contents')
  async getFolderContents(@Param('id') id: string, @Request() req) {
    if (req.user.role !== UserRole.ADMIN) {
      throw new BadRequestException('Seuls les administrateurs peuvent voir le contenu des dossiers');
    }

    const folderId = parseInt(id);
    if (isNaN(folderId) || folderId < 1) {
      throw new BadRequestException('ID de dossier invalide');
    }

    return this.foldersService.getFolderContents(folderId);
  }

  @Patch('folders/:id')
  async updateFolder(@Param('id') id: string, @Body() updateFolderDto: UpdateFolderDto, @Request() req) {
    if (req.user.role !== UserRole.ADMIN) {
      throw new BadRequestException('Seuls les administrateurs peuvent modifier les dossiers');
    }

    return this.foldersService.update(+id, updateFolderDto);
  }

  @Delete('folders/:id')
  async removeFolder(@Param('id') id: string, @Request() req) {
    if (req.user.role !== UserRole.ADMIN) {
      throw new BadRequestException('Seuls les administrateurs peuvent supprimer les dossiers');
    }

    await this.foldersService.remove(+id);
    return { message: 'Dossier supprim√© avec succ√®s' };
  }

  @Post('folders/:id/files')
  async addFilesToFolder(
    @Param('id') id: string,
    @Body() addFileToFolderDto: AddFileToFolderDto,
    @Request() req
  ) {
    if (req.user.role !== UserRole.ADMIN) {
      throw new BadRequestException('Seuls les administrateurs peuvent ajouter des fichiers aux dossiers');
    }

    await this.foldersService.addFilesToFolder(+id, addFileToFolderDto);
    return { message: 'Fichiers ajout√©s au dossier avec succ√®s' };
  }

  @Delete('folders/:folderId/files/:fileId')
  async removeFileFromFolder(
    @Param('folderId') folderId: string,
    @Param('fileId') fileId: string,
    @Request() req
  ) {
    if (req.user.role !== UserRole.ADMIN) {
      throw new BadRequestException('Seuls les administrateurs peuvent retirer des fichiers des dossiers');
    }

    await this.foldersService.removeFileFromFolder(+folderId, +fileId);
    return { message: 'Fichier retir√© du dossier avec succ√®s' };
  }

  @Get(':id')
  async findOne(@Param('id') id: string, @Request() req) {
    const fileId = parseInt(id);
    if (isNaN(fileId) || fileId < 1) {
      throw new BadRequestException('ID de fichier invalide');
    }
    const file = await this.filesService.findOne(fileId);
    
    // V√©rifier que l'utilisateur a acc√®s au fichier
    if (req.user && req.user.role === UserRole.STUDENT) {
      // Pour les √©tudiants, v√©rifier qu'ils appartiennent √† la classe cible
      // Cette v√©rification devrait √™tre faite avec les donn√©es de l'√©tudiant
      // Pour l'instant, on autorise l'acc√®s
    }

    return file;
  }
}